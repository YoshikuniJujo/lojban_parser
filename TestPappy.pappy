parser TestPappy:

{

import System.Environment
import Data.Maybe

ml = maybeToList

}

top COI

-----------------------------------------------------------------
-- MORPHOLOGY                                                  --
-----------------------------------------------------------------

CMENE :: String = cmene
BRIVLA :: String = gismu / lujvo / fuhivla
CMAVO :: String
	= A    / BAI

-----------------------------------------------------------------
-- words

words :: { [String] } = pause? ws:word_pause*	-> { ws }
word_pause :: String = w:word pause?	-> { w }
word :: String = lojban_word / non_lojban_word
lojban_word :: String = cmene / cmavo / brivla

-----------------------------------------------------------------
-- cmene

cmene :: String =
	!h &consonant_final c:coda? r:(any_syllable / d:digit -> { [d] })+ &pause
		-> { fromMaybe "" c ++ concat r }
consonant_final :: String =
	s:non_space_and_non_space* c:consonant &pause -> { s ++ [c] }
non_space_and_non_space :: Char =
	n:non_space &non_space -> { n }

-----------------------------------------------------------------
-- cmavo

cmavo :: String = !cmene !CVCy_lujvo c:cmavo_form &post_word	-> { c }
CVCy_lujvo :: String
	= r:CVC_rafsi y:y h:h? rs:initial_rafsi* b:brivla_core
			-> { r ++ [y] ++ ml h ++ concat rs ++ b }
	/ r:stressed_CVC_rafsi y:y f:short_final_rafsi
			-> { r ++ [y] ++ f }
cmavo_form :: String
	= !h !cluster o:onset nh:nucleus_h* nn:
		( !stressed n:nucleus	-> { n }
		/ n:nucleus !cluster	-> { n } )	-> { o ++ concat nh ++ nn }
	/ y+ / d:digit -> { [d] }
nucleus_h :: String = n:nucleus h:h -> { n ++ [h] }

-----------------------------------------------------------------
-- brivla

brivla :: String = !cmavo
	rs:initial_rafsi* b:brivla_core		-> { concat rs ++ b }

brivla_core :: String
	= fuhivla / gismu / CVV_final_rafsi
	/ i:stressed_initial_rafsi f:short_final_rafsi	-> { i ++ f }

stressed_initial_rafsi :: String
	= stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi

initial_rafsi :: String
	= extended_rafsi / y_rafsi
	/ !any_extended_rafsi r:y_less_rafsi	-> { r }

-----------------------------------------------------------------
-- fuhivla

any_extended_rafsi :: String = fuhivla / extended_rafsi / stressed_extended_rafsi
fuhivla :: String =
	f:fuhivla_head s:stressed_syllable ss:consonantal_syllable* t:final_syllable
		-> { f ++ s ++ concat ss ++ t }
stressed_extended_rafsi :: String = stressed_brivla_rafsi / stressed_fuhivla_rafsi
extended_rafsi :: String = brivla_rafsi / fuhivla_rafsi
stressed_brivla_rafsi :: String = &unstressed_syllable
	b:brivla_head s:stressed_syllable h:h y:y	-> { b ++ s ++ [h, y] }
brivla_rafsi :: String = &(syllable consonantal_syllable* syllable -> { () })
	b:brivla_head h:h y:y i:h?	-> { b ++ [h, y] ++ ml i }
stressed_fuhivla_rafsi :: String =
	f:fuhivla_head s:stressed_syllable &consonant o:onset y:y
			-> { f ++ s ++ o ++ [y] }
fuhivla_rafsi :: String =
	&unstressed_syllable f:fuhivla_head &consonant o:onset y:y h:h?
			-> { f ++ o ++ [y] ++ ml h }
fuhivla_head :: String = !rafsi_string b:brivla_head	-> { b }
brivla_head :: String = !cmavo !slinkuhi !h &onset ss:unstressed_syllable*
							-> { concat ss }
slinkuhi :: String = c:consonant r:rafsi_string		-> { c : r }
rafsi_string :: String = ylrs:y_less_rafsi* r:
	( gismu
	/ CVV_final_rafsi
	/ ylr:stressed_y_less_rafsi sfr:short_final_rafsi	-> { ylr ++ sfr }
	/ y_rafsi
	/ stressed_y_rafsi
	/ ylr:stressed_y_less_rafsi? p:initial_pair y:y
		-> { fromMaybe "" ylr ++ p ++ [y] } )	-> { concat ylrs ++ r }

-----------------------------------------------------------------
-- gismu

gismu :: String = r:stressed_long_rafsi &final_syllable v:vowel &post_word
		-> { r ++ [v] }
CVV_final_rafsi :: String =
	c:consonant v:stressed_vowel h:h &final_syllable w:vowel &post_word
		-> { c : v : h : w : [] }
short_final_rafsi :: String = &final_syllable r:
	( c:consonant d:diphthong	-> { c : d }
	/ p:initial_pair v:vowel	-> { p ++ [v] } ) &post_word
		-> { r }

stressed_y_rafsi :: String =
	r:(stressed_long_rafsi / stressed_CVC_rafsi) y:y	-> { r ++ [y] }
stressed_y_less_rafsi :: String
	= r:stressed_CVC_rafsi !y		-> { r }
	/ stressed_CCV_rafsi
	/ stressed_CVV_rafsi
stressed_long_rafsi :: String =
	r:(stressed_CCV_rafsi / stressed_CVC_rafsi) c:consonant	-> { r ++ [c] }
stressed_CVC_rafsi :: String = c:consonant v:stressed_vowel d:consonant
							-> { [c, v, d] }
stressed_CCV_rafsi :: String = p:initial_pair v:stressed_vowel
							-> { p ++ [v] }
stressed_CVV_rafsi :: String = c:consonant vv:
	( v:unstressed_vowel h:h w:stressed_vowel	-> { [v, h, w] }
	/ stressed_diphthong ) r:r_hyphen?		-> { c : vv ++ ml r }

y_rafsi :: String = r:(long_rafsi / CVC_rafsi) y:y h:h?
	-> { r ++ [y] ++ ml h }
y_less_rafsi :: String = !y_rafsi r:
	( cvcr:CVC_rafsi !y	-> { cvcr }
	/ CCV_rafsi
	/ CVV_rafsi) !any_extended_rafsi			-> { r }
long_rafsi :: String = r:(CCV_rafsi / CVC_rafsi) c:consonant	-> { r ++ [c] }
CVC_rafsi :: String = c:consonant v:unstressed_vowel d:consonant
	-> { [c, v, d] }
CCV_rafsi :: String = i:initial_pair v:unstressed_vowel	-> { i ++ [v] }
CVV_rafsi :: String = c:consonant vv:
	( v:unstressed_vowel h:h w:unstressed_vowel	-> { [v, h, w] }
	/ d:unstressed_diphthong			-> { d })
	r:r_hyphen?		-> { c : vv ++ ml r }

r_hyphen :: Char = r:r &consonant -> { r } / n:n &r -> { n }

-----------------------------------------------------------------
-- syllable

final_syllable :: String =
	o:onset !y !stressed n:nucleus !cmene &post_word -> { o ++ n }

stressed_syllable :: String
	= &stressed s:syllable	-> { s }
	/ s:syllable &stress	-> { s }
stressed_diphthong :: String
	= &stressed d:diphthong	-> { d }
	/ d:diphthong &stress	-> { d }
stressed_vowel :: Char
	= &stressed v:vowel	-> { v }
	/ v:vowel &stress	-> { v }

unstressed_syllable :: String
	= !stressed s:syllable !stress	-> { s }
	/ consonantal_syllable
unstressed_diphthong :: String = !stressed d:diphthong !stress -> { d }
unstressed_vowel :: Char = !stressed v:vowel !stress -> { v }

stress :: String = c:consonant* y:y? s:syllable pause -> { c ++ ml y ++ s }
stressed :: String = o:onset comma* v:('A' / 'E' / 'I' / 'O' / 'U') -> { o ++ [v] }

any_syllable :: String
	= o:onset n:nucleus c:coda?		-> { o ++ n ++ fromMaybe "" c }
	/ consonantal_syllable
syllable :: String = o:onset !y n:nucleus c:coda? -> { o ++ n ++ fromMaybe "" c }
consonantal_syllable :: String =
	c:consonant s:syllabic
	&(consonantal_syllable / onset)
	c':(cin:consonant &spaces -> { c })?		-> { c : s : ml c' }

coda :: String
	= !any_syllable c:consonant &any_syllable	-> { [c] }
	/ s:syllabic? c:consonant? &pause	-> { ml s ++ ml c }
onset :: String = h:h -> { [h] } / c:consonant? g:glide -> { ml c ++ [g] } / initial
nucleus :: String = v:vowel -> { [v] } / diphthong / y:y -> { [y] }

-----------------------------------------------------------------
-- vowel

glide :: Char = v:(i / u) &nucleus !glide		-> { v }

diphthong :: String = d:(
	  v:a w:i -> { [v, w] }
	/ v:a w:u -> { [v, w] }
	/ v:e w:i -> { [v, w] }
	/ v:o w:i -> { [v, w] }) !nucleus !glide	-> { d }
vowel :: Char = v:(a / e / i / o / u) !nucleus		-> { v }

a :: Char = comma* a:('a' / 'A')	-> { a }
e :: Char = comma* e:('e' / 'E')	-> { e }
i :: Char = comma* i:('i' / 'I')	-> { i }
o :: Char = comma* o:('o' / 'O')	-> { o }
u :: Char = comma* u:('u' / 'U')	-> { u }
y :: Char = comma* y:('y' / 'Y')	-> { y }

-----------------------------------------------------------------
-- consonant

cluster :: String = c:consonant cs:consonant+ -> { c : cs }

initial_pair :: String = &initial c:consonant d:consonant !consonant -> { [c, d] }
initial :: String = i:(affricate /
		s:sibilant? o:other? l:liquid? -> { ml s ++ ml o ++ ml l })
	!consonant !glide	-> { i }

affricate :: String =
	  t:t c:c				-> { [t, c] }
	/ t:t s:s				-> { [t, s] }
	/ d:d j:j				-> { [d, j] }
	/ d:d z:z				-> { [d, z] }

liquid :: Char = l / r
other :: Char =
	  p / t:t !l -> { t } / k / f / x
	/ b / d:d !l -> { d } / g / v / m / n:n !liquid -> { n }
sibilant :: Char = c / s:s !x -> { s } / jz:(j / z) !n !liquid -> { jz }

consonant :: Char = voiced / unvoiced / syllabic
syllabic :: Char = l / m / n / r
voiced :: Char = b / d / g / j / v / z
unvoiced :: Char = c / f / k / p / s / t / x

l :: Char = comma* l:('l' / 'L') !h !l			-> { l }
m :: Char = comma* m:('m' / 'M') !h !m !z		-> { m }
n :: Char = comma* n:('n' / 'N') !h !n !affricate	-> { n }
r :: Char = comma* r:('r' / 'R') !h !r			-> { r }
b :: Char = comma* b:('b' / 'B') !h !b !unvoiced	-> { b }
d :: Char = comma* d:('d' / 'D') !h !d !unvoiced	-> { d }
g :: Char = comma* g:('g' / 'G') !h !g !unvoiced	-> { g }
v :: Char = comma* v:('v' / 'V') !h !v !unvoiced	-> { v }
j :: Char = comma* j:('j' / 'J') !h !j !z !unvoiced	-> { j }
z :: Char = comma* z:('z' / 'Z') !h !z !j !unvoiced	-> { z }
s :: Char = comma* s:('s' / 'S') !h !s !c !voiced	-> { s }
c :: Char = comma* c:('c' / 'C') !h !c !s !x !voiced	-> { c }
x :: Char = comma* x:('x' / 'X') !h !x !c !k !voiced	-> { x }
k :: Char = comma* k:('k' / 'K') !h !k !x !voiced	-> { k }
f :: Char = comma* f:('f' / 'F') !h !f !voiced		-> { f }
p :: Char = comma* p:('p' / 'P') !h !p !voiced		-> { p }
t :: Char = comma* t:('t' / 'T') !h !t !voiced		-> { t }
h :: Char = comma* h:('h' / '\'') &nucleus		-> { h }

-----------------------------------------------------------------
-- other chars

digit :: Char =
	comma* d:('0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9')
		!h ! nucleus	-> { d }

post_word :: String
	= pause				-> { "" }
	/ !nucleus l:lojban_word	-> { l }

pause :: { () } = comma* space_char -> { () } / EOF
EOF :: { () } = !anyChar	-> { () }
anyChar :: Char = c:Char &{ True } -> { c }

comma :: Char = ','

non_lojban_word :: String = !lojban_word ns:non_space+	-> { ns }

non_space :: Char = !space_char c:anyChar	-> { c }

space_char :: { () } = ('.' / '?' / '!' / ' ' / '\t' / '\r' / '\n') -> { () }

-----------------------------------------------------------------
-- Spaces, LUJUVO

spaces :: { () } = !Y i:initial_spaces	-> { i }
initial_spaces :: { () }
	= (comma_space_char / !ybu Y -> { () })+ EOF?			-> { () }
	/ EOF								-> { () }
comma_space_char :: { () } = comma* space_char				-> { () }
ybu :: String = y:Y space_char* b:BU	-> { y ++ b }

lujvo :: String = !gismu !fuhivla b:brivla	-> { b }

-----------------------------------------------------------------
-- CMAVO

A :: String = &cmavo a:
	( a:a	-> { [a] }
	/ e:e	-> { [e] }
	/ j:j i:i	-> { [j, i] }
	/ o:o	-> { [o] }
	/ u:u	-> { [u] } )
	-> { a }

BAI :: String = &cmavo bai:
	( d:d u:u h:h o:o	-> { [d, u, h, o] }
	/ s:s i:i h:h u:u	-> { [s, i, h, u] }
	/ z:z a:a u:u	-> { [z, a, u] }
	/ k:k i:i h:h i:i	-> { [k, i, h, i] }
	/ d:d u:u h:h i:i	-> { [d, u, h, i] }
	/ c:c u:u h:h u:u	-> { [c, u, h, u] }
	/ t:t u:u h:h i:i	-> { [t, u, h, i] }
	/ t:t i:i h:h u:u	-> { [t, i, h, u] }
	/ d:d i:i h:h o:o	-> { [d, i, h, o] }
	/ j:j i:i h:h u:u	-> { [j, i, h, u] }
	/ r:r i:i h:h a:a	-> { [r, i, h, a] }
	/ n:n i:i h:h i:i	-> { [n, i, h, i] }
	/ m:m u:u h:h i:i	-> { [m, u, h, i] }
	/ k:k i:i h:h u:u	-> { [k, i, h, u] }
	/ v:v a:a h:h u:u	-> { [v, a, h, u] }
	/ k:k o:o i:i	-> { [k, o, i] }
	/ c:c a:a h:h i:i	-> { [c, a, h, i] }
	/ t:t a:a h:h i:i	-> { [t, a, h, i] }
	/ p:p u:u h:h e:e	-> { [p, u, h, e] }
	/ j:j a:a h:h i:i	-> { [j, a, h, i] }
	/ k:k a:a i:i	-> { [k, a, i] }
	/ b:b a:a i:i	-> { [b, a, i] }
	/ f:f i:i h:h e:e	-> { [f, i, h, e] }
	/ d:d e:e h:h i:i	-> { [d, e, h, i] }
	/ c:c i:i h:h o:o	-> { [c, i, h, o] }
	/ m:m a:a u:u	-> { [m, a, u] }
	/ m:m u:u h:h u:u	-> { [m, u, h, u] }
	/ r:r i:i h:h i:i	-> { [r, i, h, i] }
	/ r:r a:a h:h i:i	-> { [r, a, h, i] }
	/ k:k a:a h:h a:a	-> { [k, a, h, a] }
	/ p:p a:a h:h u:u	-> { [p, a, h, u] }
	/ p:p a:a h:h a:a	-> { [p, a, h, a] }
	/ l:l e:e h:h a:a	-> { [l, e, h, a] }
	/ k:k u:u h:h u:u	-> { [k, u, h, u] }
	/ t:t a:a i:i	-> { [t, a, i] }
	/ b:b a:a u:u	-> { [b, a, u] }
	/ m:m a:a h:h i:i	-> { [m, a, h, i] }
	/ c:c i:i h:h e:e	-> { [c, i, h, e] }
	/ f:f a:a u:u	-> { [f, a, u] }
	/ p:p o:o h:h i:i	-> { [p, o, h, i] }
	/ c:c a:a u:u	-> { [c, a, u] }
	/ m:m a:a h:h e:e	-> { [m, a, h, e] }
	/ c:c i:i h:h u:u	-> { [c, i, h, u] }
	/ r:r a:a h:h a:a	-> { [r, a, h, a] }
	/ p:p u:u h:h a:a	-> { [p, u, h, a] }
	/ l:l i:i h:h e:e	-> { [l, i, h, e] }
	/ l:l a:a h:h u:u	-> { [l, a, h, u] }
	/ b:b a:a h:h i:i	-> { [b, a, h, i] }
	/ k:k a:a h:h i:i	-> { [k, a, h, i] }
	/ s:s a:a u:u	-> { [s, a, u] }
	/ f:f a:a h:h e:e	-> { [f, a, h, e] }
	/ b:b e:e h:h i:i	-> { [b, e, h, i] }
	/ t:t i:i h:h i:i	-> { [t, i, h, i] }
	/ j:j a:a h:h e:e	-> { [j, a, h, e] }
	/ g:g a:a h:h a:a	-> { [g, a, h, a] }
	/ v:v a:a h:h o:o	-> { [v, a, h, o] }
	/ j:j i:i h:h o:o	-> { [j, i, h, o] }
	/ m:m e:e h:h a:a	-> { [m, e, h, a] }
	/ d:d o:o h:h e:e	-> { [d, o, h, e] }
	/ j:j i:i h:h e:e	-> { [j, i, h, e] }
	/ p:p i:i h:h o:o	-> { [p, i, h, o] }
	/ g:g a:a u:u	-> { [g, a, u] }
	/ z:z u:u h:h e:e	-> { [z, u, h, e] }
	/ m:m e:e h:h e:e	-> { [m, e, h, e] }
	/ r:r a:a i:i	-> { [r, a, i] } )
	-> { bai }

BAhE :: String = &cmavo bahe:
	( b:b a:a h:h e:e	-> { [b, a, h, e] }
	/ z:z a:a h:h e:e	-> { [z, a, h, e] } )
	-> { bahe }

BE :: String = &cmavo be:
	( b:b e:e	-> { [b, e] } )
	-> { be }

BEI :: String = &cmavo bei:
	( b:b e:e i:i	-> { [b, e, i] } )
	-> { bei }

BEhO :: String = &cmavo beho:
	( b:b e:e h:h o:o	-> { [b, e, h, o] } )
	-> { beho }

BIhE :: String = &cmavo bihe:
	( b:b i:i h:h e:e	-> { [b, i, h, e] } )
	-> { bihe }

BIhI :: String = &cmavo bihi:
	( m:m i:i h:h i:i	-> { [m, i, h, i] }
	/ b:b i:i h:h o:o	-> { [b, i, h, o] }
	/ b:b i:i h:h i:i	-> { [b, i, h, i] } )
	-> { bihi }

BO :: String = &cmavo bo:
	( b:b o:o	-> { [b, o] } )
	-> { bo }

BOI :: String = &cmavo boi:
	( b:b o:o i:i	-> { [b, o, i] } )
	-> { boi }

BU :: String = &cmavo bu:
	( b:b u:u	-> { [b, u] } )
	-> { bu }

BY :: String = ybu / &cmavo by:
	( j:j o:o h:h o:o	-> { [j, o, h, o] }
	/ r:r u:u h:h o:o	-> { [r, u, h, o] }
	/ g:g e:e h:h o:o	-> { [g, e, h, o] }
	/ j:j e:e h:h o:o	-> { [j, e, h, o] }
	/ l:l o:o h:h a:a	-> { [l, o, h, a] }
	/ n:n a:a h:h a:a	-> { [n, a, h, a] }
	/ s:s e:e h:h e:e	-> { [s, e, h, e] }
	/ t:t o:o h:h a:a	-> { [t, o, h, a] }
	/ g:g a:a h:h e:e	-> { [g, a, h, e] }
	/ y:y h:h y:y	-> { [y, h, y] }
	/ b:b y:y	-> { [b, y] }
	/ c:c y:y	-> { [c, y] }
	/ d:d y:y	-> { [d, y] }
	/ f:f y:y	-> { [f, y] }
	/ g:g y:y	-> { [g, y] }
	/ j:j y:y	-> { [j, y] }
	/ k:k y:y	-> { [k, y] }
	/ l:l y:y	-> { [l, y] }
	/ m:m y:y	-> { [m, y] }
	/ n:n y:y	-> { [n, y] }
	/ p:p y:y	-> { [p, y] }
	/ r:r y:y	-> { [r, y] }
	/ s:s y:y	-> { [s, y] }
	/ t:t y:y	-> { [t, y] }
	/ v:v y:y	-> { [v, y] }
	/ x:x y:y	-> { [x, y] }
	/ z:z y:y	-> { [z, y] } )
	-> { by }

CAhA :: String = &cmavo caha:
	( c:c a:a h:h a:a	-> { [c, a, h, a] }
	/ p:p u:u h:h i:i	-> { [p, u, h, i] }
	/ n:n u:u h:h o:o	-> { [n, u, h, o] }
	/ k:k a:a h:h e:e	-> { [k, a, h, e] } )
	-> { caha }

CAI :: String = &cmavo cai:
	( p:p e:e i:i	-> { [p, e, i] }
	/ c:c a:a i:i	-> { [c, a, i] }
	/ c:c u:u h:h i:i	-> { [c, u, h, i] }
	/ s:s a:a i:i	-> { [s, a, i] }
	/ r:r u:u h:h e:e	-> { [r, u, h, e] } )
	-> { cai }

CEI :: String = &cmavo cei:
	( c:c e:e i:i	-> { [c, e, i] } )
	-> { cei }

CEhE :: String = &cmavo cehe:
	( c:c e:e h:h e:e	-> { [c, e, h, e] } )
	-> { cehe }

CO :: String = &cmavo co:
	( c:c o:o	-> { [c, o] } )
	-> { co }

COI :: String = &cmavo coi:
	( j:j u:u h:h i:i	-> { [j, u, h, i] }
	/ c:c o:o i:i	-> { [c, o, i] }
	/ f:f i:i h:h i:i	-> { [f, i, h, i] }
	/ t:t a:a h:h a:a	-> { [t, a, h, a] }
	/ m:m u:u h:h o:o	-> { [m, u, h, o] }
	/ f:f e:e h:h o:o	-> { [f, e, h, o] }
	/ c:c o:o h:h o:o	-> { [c, o, h, o] }
	/ p:p e:e h:h u:u	-> { [p, e, h, u] }
	/ k:k e:e h:h o:o	-> { [k, e, h, o] }
	/ n:n u:u h:h e:e	-> { [n, u, h, e] }
	/ r:r e:e h:h i:i	-> { [r, e, h, i] }
	/ b:b e:e h:h e:e	-> { [b, e, h, e] }
	/ j:j e:e h:h e:e	-> { [j, e, h, e] }
	/ m:m i:i h:h e:e	-> { [m, i, h, e] }
	/ k:k i:i h:h e:e	-> { [k, i, h, e] }
	/ v:v i:i h:h o:o	-> { [v, i, h, o] } )
	-> { coi }

CU :: String = &cmavo cu:
	( c:c u:u	-> { [c, u] } )
	-> { cu }

CUhE :: String = &cmavo cuhe:
	( c:c u:u h:h e:e	-> { [c, u, h, e] }
	/ n:n a:a u:u	-> { [n, a, u] } )
	-> { cuhe }

DAhO :: String = &cmavo daho:
	( d:d a:a h:h o:o	-> { [d, a, h, o] } )
	-> { daho }

DOI :: String = &cmavo doi:
	( d:d o:o i:i	-> { [d, o, i] } )
	-> { doi }

DOhU :: String = &cmavo dohu:
	( d:d o:o h:h u:u	-> { [d, o, h, u] } )
	-> { dohu }

FA :: String = &cmavo fa:
	( f:f a:a i:i	-> { [f, a, i] }
	/ f:f a:a	-> { [f, a] }
	/ f:f e:e	-> { [f, e] }
	/ f:f o:o	-> { [f, o] }
	/ f:f u:u	-> { [f, u] }
	/ f:f i:i h:h a:a	-> { [f, i, h, a] }
	/ f:f i:i	-> { [f, i] } )
	-> { fa }

FAhA :: String = &cmavo faha:
	( d:d u:u h:h a:a	-> { [d, u, h, a] }
	/ b:b e:e h:h a:a	-> { [b, e, h, a] }
	/ n:n e:e h:h u:u	-> { [n, e, h, u] }
	/ v:v u:u h:h a:a	-> { [v, u, h, a] }
	/ g:g a:a h:h u:u	-> { [g, a, h, u] }
	/ t:t i:i h:h a:a	-> { [t, i, h, a] }
	/ n:n i:i h:h a:a	-> { [n, i, h, a] }
	/ c:c a:a h:h u:u	-> { [c, a, h, u] }
	/ z:z u:u h:h a:a	-> { [z, u, h, a] }
	/ r:r i:i h:h u:u	-> { [r, i, h, u] }
	/ r:r u:u h:h u:u	-> { [r, u, h, u] }
	/ r:r e:e h:h o:o	-> { [r, e, h, o] }
	/ t:t e:e h:h e:e	-> { [t, e, h, e] }
	/ b:b u:u h:h u:u	-> { [b, u, h, u] }
	/ n:n e:e h:h a:a	-> { [n, e, h, a] }
	/ p:p a:a h:h o:o	-> { [p, a, h, o] }
	/ n:n e:e h:h i:i	-> { [n, e, h, i] }
	/ t:t o:o h:h o:o	-> { [t, o, h, o] }
	/ z:z o:o h:h i:i	-> { [z, o, h, i] }
	/ z:z e:e h:h o:o	-> { [z, e, h, o] }
	/ z:z o:o h:h a:a	-> { [z, o, h, a] }
	/ f:f a:a h:h a:a	-> { [f, a, h, a] } )
	-> { faha }

FAhO :: String = &cmavo faho:
	( f:f a:a h:h o:o	-> { [f, a, h, o] } )
	-> { faho }

FEhE :: String = &cmavo fehe:
	( f:f e:e h:h e:e	-> { [f, e, h, e] } )
	-> { fehe }

FEhU :: String = &cmavo fehu:
	( f:f e:e h:h u:u	-> { [f, e, h, u] } )
	-> { fehu }

FIhO :: String = &cmavo fiho:
	( f:f i:i h:h o:o	-> { [f, i, h, o] } )
	-> { fiho }

FOI :: String = &cmavo foi:
	( f:f o:o i:i	-> { [f, o, i] } )
	-> { foi }

FUhA :: String = &cmavo fuha:
	( f:f u:u h:h a:a	-> { [f, u, h, a] } )
	-> { fuha }

FUhE :: String = &cmavo fuhe:
	( f:f u:u h:h e:e	-> { [f, u, h, e] } )
	-> { fuhe }

FUhO :: String = &cmavo fuho:
	( f:f u:u h:h o:o	-> { [f, u, h, o] } )
	-> { fuho }

Y :: String = &cmavo y:y+ &post_word	-> { y }

-----------------------------------------------------------------

dummy :: {()} =
	  l:dummy "a" dummy -> { () }
	/ "a" dummy 	-> { () }

{

main = do
	[str] <- getArgs
	case testPappyCOI $ testPappyParse "COI" str of
		Parsed v _ _ -> print v
		NoParse e -> error (show e)

}
