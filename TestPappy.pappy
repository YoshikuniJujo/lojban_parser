parser TestPappy:

{

import System.Environment
import Data.Maybe

ml = maybeToList

}

top words

-----------------------------------------------------------------
-- MORPHOLOGY                                                  --
-----------------------------------------------------------------

-----------------------------------------------------------------
-- words

words :: { [String] } = pause? ws:word_pause*	-> { ws }
word_pause :: String = w:word pause?	-> { w }
word :: String = lojban_word / non_lojban_word
lojban_word :: String = cmene / cmavo / brivla

-----------------------------------------------------------------
-- cmene

cmene :: String =
	!h &consonant_final c:coda? r:(any_syllable / d:digit -> { [d] })+ &pause
		-> { fromMaybe "" c ++ concat r }
consonant_final :: String =
	s:non_space_and_non_space* c:consonant &pause -> { s ++ [c] }
non_space_and_non_space :: Char =
	n:non_space &non_space -> { n }

-----------------------------------------------------------------
-- cmavo

cmavo :: String = !cmene !CVCy_lujvo c:cmavo_form &post_word	-> { c }
CVCy_lujvo :: String
	= r:CVC_rafsi y:y h:h? rs:initial_rafsi* b:brivla_core
			-> { r ++ [y] ++ ml h ++ concat rs ++ b }
	/ r:stressed_CVC_rafsi y:y f:short_final_rafsi
			-> { r ++ [y] ++ f }
cmavo_form :: String
	= !h !cluster o:onset nh:nucleus_h* nn:
		( !stressed n:nucleus	-> { n }
		/ n:nucleus !cluster	-> { n } )	-> { o ++ concat nh ++ nn }
	/ y+ / d:digit -> { [d] }
nucleus_h :: String = n:nucleus h:h -> { n ++ [h] }

-----------------------------------------------------------------
-- brivla

brivla :: String = !cmavo
	rs:initial_rafsi* b:brivla_core		-> { concat rs ++ b }

brivla_core :: String
	= fuhivla / gismu / CVV_final_rafsi
	/ i:stressed_initial_rafsi f:short_final_rafsi	-> { i ++ f }

stressed_initial_rafsi :: String
	= stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi

initial_rafsi :: String
	= extended_rafsi / y_rafsi
	/ !any_extended_rafsi r:y_less_rafsi	-> { r }

-----------------------------------------------------------------
-- fuhivla

any_extended_rafsi :: String = fuhivla / extended_rafsi / stressed_extended_rafsi
fuhivla :: String =
	f:fuhivla_head s:stressed_syllable ss:consonantal_syllable* t:final_syllable
		-> { f ++ s ++ concat ss ++ t }
stressed_extended_rafsi :: String = stressed_brivla_rafsi / stressed_fuhivla_rafsi
extended_rafsi :: String = brivla_rafsi / fuhivla_rafsi
stressed_brivla_rafsi :: String = &unstressed_syllable
	b:brivla_head s:stressed_syllable h:h y:y	-> { b ++ s ++ [h, y] }
brivla_rafsi :: String = &(syllable consonantal_syllable* syllable -> { () })
	b:brivla_head h:h y:y i:h?	-> { b ++ [h, y] ++ ml i }
stressed_fuhivla_rafsi :: String =
	f:fuhivla_head s:stressed_syllable &consonant o:onset y:y
			-> { f ++ s ++ o ++ [y] }
fuhivla_rafsi :: String =
	&unstressed_syllable f:fuhivla_head &consonant o:onset y:y h:h?
			-> { f ++ o ++ [y] ++ ml h }
fuhivla_head :: String = !rafsi_string b:brivla_head	-> { b }
brivla_head :: String = !cmavo !slinkuhi !h &onset ss:unstressed_syllable*
							-> { concat ss }
slinkuhi :: String = c:consonant r:rafsi_string		-> { c : r }
rafsi_string :: String = ylrs:y_less_rafsi* r:
	( gismu
	/ CVV_final_rafsi
	/ ylr:stressed_y_less_rafsi sfr:short_final_rafsi	-> { ylr ++ sfr }
	/ y_rafsi
	/ stressed_y_rafsi
	/ ylr:stressed_y_less_rafsi? p:initial_pair y:y
		-> { fromMaybe "" ylr ++ p ++ [y] } )	-> { concat ylrs ++ r }

-----------------------------------------------------------------
-- gismu

gismu :: String = r:stressed_long_rafsi &final_syllable v:vowel &post_word
		-> { r ++ [v] }
CVV_final_rafsi :: String =
	c:consonant v:stressed_vowel h:h &final_syllable w:vowel &post_word
		-> { c : v : h : w : [] }
short_final_rafsi :: String = &final_syllable r:
	( c:consonant d:diphthong	-> { c : d }
	/ p:initial_pair v:vowel	-> { p ++ [v] } ) &post_word
		-> { r }

stressed_y_rafsi :: String =
	r:(stressed_long_rafsi / stressed_CVC_rafsi) y:y	-> { r ++ [y] }
stressed_y_less_rafsi :: String
	= r:stressed_CVC_rafsi !y		-> { r }
	/ stressed_CCV_rafsi
	/ stressed_CVV_rafsi
stressed_long_rafsi :: String =
	r:(stressed_CCV_rafsi / stressed_CVC_rafsi) c:consonant	-> { r ++ [c] }
stressed_CVC_rafsi :: String = c:consonant v:stressed_vowel d:consonant
							-> { [c, v, d] }
stressed_CCV_rafsi :: String = p:initial_pair v:stressed_vowel
							-> { p ++ [v] }
stressed_CVV_rafsi :: String = c:consonant vv:
	( v:unstressed_vowel h:h w:stressed_vowel	-> { [v, h, w] }
	/ stressed_diphthong ) r:r_hyphen?		-> { c : vv ++ ml r }

y_rafsi :: String = r:(long_rafsi / CVC_rafsi) y:y h:h?
	-> { r ++ [y] ++ ml h }
y_less_rafsi :: String = !y_rafsi r:
	( cvcr:CVC_rafsi !y	-> { cvcr }
	/ CCV_rafsi
	/ CVV_rafsi) !any_extended_rafsi			-> { r }
long_rafsi :: String = r:(CCV_rafsi / CVC_rafsi) c:consonant	-> { r ++ [c] }
CVC_rafsi :: String = c:consonant v:unstressed_vowel d:consonant
	-> { [c, v, d] }
CCV_rafsi :: String = i:initial_pair v:unstressed_vowel	-> { i ++ [v] }
CVV_rafsi :: String = c:consonant vv:
	( v:unstressed_vowel h:h w:unstressed_vowel	-> { [v, h, w] }
	/ d:unstressed_diphthong			-> { d })
	r:r_hyphen?		-> { c : vv ++ ml r }

r_hyphen :: Char = r:r &consonant -> { r } / n:n &r -> { n }

-----------------------------------------------------------------
-- syllable

final_syllable :: String =
	o:onset !y !stressed n:nucleus !cmene &post_word -> { o ++ n }

stressed_syllable :: String
	= &stressed s:syllable	-> { s }
	/ s:syllable &stress	-> { s }
stressed_diphthong :: String
	= &stressed d:diphthong	-> { d }
	/ d:diphthong &stress	-> { d }
stressed_vowel :: Char
	= &stressed v:vowel	-> { v }
	/ v:vowel &stress	-> { v }

unstressed_syllable :: String
	= !stressed s:syllable !stress	-> { s }
	/ consonantal_syllable
unstressed_diphthong :: String = !stressed d:diphthong !stress -> { d }
unstressed_vowel :: Char = !stressed v:vowel !stress -> { v }

stress :: String = c:consonant* y:y? s:syllable pause -> { c ++ ml y ++ s }
stressed :: String = o:onset comma* v:('A' / 'E' / 'I' / 'O' / 'U') -> { o ++ [v] }

any_syllable :: String
	= o:onset n:nucleus c:coda?		-> { o ++ n ++ fromMaybe "" c }
	/ consonantal_syllable
syllable :: String = o:onset !y n:nucleus c:coda? -> { o ++ n ++ fromMaybe "" c }
consonantal_syllable :: String =
	c:consonant s:syllabic
	&(consonantal_syllable / onset)
	c':(cin:consonant &spaces -> { c })?		-> { c : s : ml c' }

coda :: String
	= !any_syllable c:consonant &any_syllable	-> { [c] }
	/ s:syllabic? c:consonant? &pause	-> { ml s ++ ml c }
onset :: String = h:h -> { [h] } / c:consonant? g:glide -> { ml c ++ [g] } / initial
nucleus :: String = v:vowel -> { [v] } / diphthong / y:y -> { [y] }

-----------------------------------------------------------------
-- vowel

glide :: Char = v:(i / u) &nucleus !glide		-> { v }

diphthong :: String = d:(
	  v:a w:i -> { [v, w] }
	/ v:a w:u -> { [v, w] }
	/ v:e w:i -> { [v, w] }
	/ v:o w:i -> { [v, w] }) !nucleus !glide	-> { d }
vowel :: Char = v:(a / e / i / o / u) !nucleus		-> { v }

a :: Char = comma* a:('a' / 'A')	-> { a }
e :: Char = comma* e:('e' / 'E')	-> { e }
i :: Char = comma* i:('i' / 'I')	-> { i }
o :: Char = comma* o:('o' / 'O')	-> { o }
u :: Char = comma* u:('u' / 'U')	-> { u }
y :: Char = comma* y:('y' / 'Y')	-> { y }

-----------------------------------------------------------------
-- consonant

cluster :: String = c:consonant cs:consonant+ -> { c : cs }

initial_pair :: String = &initial c:consonant d:consonant !consonant -> { [c, d] }
initial :: String = i:(affricate /
		s:sibilant? o:other? l:liquid? -> { ml s ++ ml o ++ ml l })
	!consonant !glide	-> { i }

affricate :: String =
	  t:t c:c				-> { [t, c] }
	/ t:t s:s				-> { [t, s] }
	/ d:d j:j				-> { [d, j] }
	/ d:d z:z				-> { [d, z] }

liquid :: Char = l / r
other :: Char =
	  p / t:t !l -> { t } / k / f / x
	/ b / d:d !l -> { d } / g / v / m / n:n !liquid -> { n }
sibilant :: Char = c / s:s !x -> { s } / jz:(j / z) !n !liquid -> { jz }

consonant :: Char = voiced / unvoiced / syllabic
syllabic :: Char = l / m / n / r
voiced :: Char = b / d / g / j / v / z
unvoiced :: Char = c / f / k / p / s / t / x

l :: Char = comma* l:('l' / 'L') !h !l			-> { l }
m :: Char = comma* m:('m' / 'M') !h !m !z		-> { m }
n :: Char = comma* n:('n' / 'N') !h !n !affricate	-> { n }
r :: Char = comma* r:('r' / 'R') !h !r			-> { r }
b :: Char = comma* b:('b' / 'B') !h !b !unvoiced	-> { b }
d :: Char = comma* d:('d' / 'D') !h !d !unvoiced	-> { d }
g :: Char = comma* g:('g' / 'G') !h !g !unvoiced	-> { g }
v :: Char = comma* v:('v' / 'V') !h !v !unvoiced	-> { v }
j :: Char = comma* j:('j' / 'J') !h !j !z !unvoiced	-> { j }
z :: Char = comma* z:('z' / 'Z') !h !z !j !unvoiced	-> { z }
s :: Char = comma* s:('s' / 'S') !h !s !c !voiced	-> { s }
c :: Char = comma* c:('c' / 'C') !h !c !s !x !voiced	-> { c }
x :: Char = comma* x:('x' / 'X') !h !x !c !k !voiced	-> { x }
k :: Char = comma* k:('k' / 'K') !h !k !x !voiced	-> { k }
f :: Char = comma* f:('f' / 'F') !h !f !voiced		-> { f }
p :: Char = comma* p:('p' / 'P') !h !p !voiced		-> { p }
t :: Char = comma* t:('t' / 'T') !h !t !voiced		-> { t }
h :: Char = comma* h:('h' / '\'') &nucleus		-> { h }

-----------------------------------------------------------------
-- other chars

digit :: Char =
	comma* d:('0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9')
		!h ! nucleus	-> { d }

post_word :: String
	= pause				-> { "" }
	/ !nucleus l:lojban_word	-> { l }

pause :: { () } = comma* space_char -> { () } / EOF
EOF :: { () } = !anyChar	-> { () }
anyChar :: Char = c:Char &{ True } -> { c }

comma :: Char = ','

non_lojban_word :: String = !lojban_word ns:non_space+	-> { ns }

non_space :: Char = !space_char c:anyChar	-> { c }

space_char :: { () } = ('.' / '?' / '!' / ' ' / '\t' / '\r' / '\n') -> { () }

-----------------------------------------------------------------
-- Spaces, LUJUVO

spaces :: { () } = !Y i:initial_spaces	-> { i }
initial_spaces :: { () }
	= (comma_space_char / !ybu Y -> { () })+ EOF?			-> { () }
	/ EOF								-> { () }
comma_space_char :: { () } = comma* space_char				-> { () }
ybu :: { () } = Y space_char* BU	-> { () }

-- lujvo :: String = !gismu !fuhivla brivla

-----------------------------------------------------------------
-- CMAVO

BU :: { () } = &cmavo b u &post_word	-> { () }

Y :: { () } = &cmavo y+ &post_word	-> { () }

-----------------------------------------------------------------

dummy :: {()} =
	  l:dummy "a" dummy -> { () }
	/ "a" dummy 	-> { () }

{

main = do
	[str] <- getArgs
	case testPappywords $ testPappyParse "words" str of
		Parsed v _ _ -> print v
		NoParse e -> error (show e)

}
